import { Innertube } from 'youtubei.js';
import { Thumbnail } from 'youtubei.js/dist/src/parser/misc';

import { PunctuatorService } from './punctuator-service';

export interface YoutubeTranscriptSourceMetadata {
  title: string | undefined;
  channel: {
    id: string;
    name: string;
  } | null;
  videoId: string;
  duration: number | undefined;
  thumbnail: Thumbnail[] | undefined;
  description: string | undefined;
  keywords: string[] | undefined;
}

export interface YoutubeTranscriptSegment {
  start: number;
  end: number;
  text: string;
}

export class YoutubeTranscriptHandler {
  private readonly OVERLAP_WORDS = 1;

  constructor(private punctuator: PunctuatorService) {}

  async fetchRecord(url: string) {
    const videoId = YoutubeTranscriptHandler.getVideoID(url);
    const raw = await this.transcriptYoutubeVideo(videoId);

    if (!raw) {
      return null;
    }

    const transcript = raw.autoGenerated ? await this.punctuateTranscript(raw.transcript) : raw.transcript;

    return {
      transcript,
      metadata: {
        title: raw.info.title,
        channel: raw.info.channel
          ? {
              id: raw.info.channel?.id,
              name: raw.info.channel?.name,
            }
          : null,
        videoId,
        duration: raw.info.duration,
        thumbnail: raw.info.thumbnail,
        description: raw.info.short_description,
        keywords: raw.info.keywords,
      },
    };
  }

  async transcriptYoutubeVideo(videoId: string) {
    const innertube = await Innertube.create({ lang: 'en', retrieve_player: false });

    const info = await innertube.getInfo(videoId);
    const transcriptData = await info.getTranscript();

    if (!transcriptData.transcript.content?.body?.initial_segments) {
      return null;
    }

    const transcript = transcriptData.transcript.content.body.initial_segments
      .filter((e) => !e.snippet.isEmpty())
      .map((segment) => ({
        start: Number(segment.start_ms),
        end: Number(segment.end_ms),
        text: segment.snippet.text ?? '',
      }));

    return {
      transcript,
      info: info.basic_info,
      autoGenerated: transcriptData.transcript.content.footer?.language_menu?.sub_menu_items
        ?.find((e) => e.selected == true)
        ?.title.includes('auto-generated'),
    };
  }

  async punctuateTranscript(transcript: YoutubeTranscriptSegment[]) {
    // NOTE: this will always assume each segment is at least OVERLAP_WORDS words long

    return transcript.reduce(async (pAcc, e, i, arr) => {
      const acc = await pAcc;
      const prevWords = i > 0 ? acc[i - 1]!.text.split(' ').slice(-this.OVERLAP_WORDS) : [];
      const nextWords = i < arr.length - 1 ? arr[i + 1]!.text.split(' ').slice(0, this.OVERLAP_WORDS) : [];

      const str = `${prevWords.join(' ')} ${e.text} ${nextWords.join(' ')}`.trim();
      const punctuated = await this.punctuator.punctuate(str);

      const text = punctuated.text
        .split(' ')
        .slice(i > 0 ? this.OVERLAP_WORDS : 0, i < arr.length - 1 ? -this.OVERLAP_WORDS : undefined)
        .join(' ');

      acc.push({
        ...e,
        text,
      });

      return acc;
    }, Promise.resolve<YoutubeTranscriptSegment[]>([]));
  }

  public static getVideoID(url: string): string {
    const match = /.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#&?]*).*/.exec(url);
    if (match !== null && match[1]?.length === 11) {
      return match[1];
    } else {
      throw new Error('Failed to get youtube video id from the url');
    }
  }
}
