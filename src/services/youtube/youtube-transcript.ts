import { Innertube } from 'youtubei.js';
import type { Thumbnail } from 'youtubei.js/dist/src/parser/misc';

import type { PunctuatorService } from './punctuator-service';

export interface YoutubeTranscriptSourceMetadata {
  title: string | undefined;
  channel: {
    id: string;
    name: string;
  } | null;
  videoId: string;
  duration: number | undefined;
  thumbnail: Thumbnail[] | undefined;
  description: string | undefined;
  keywords: string[] | undefined;
}

export interface YoutubeTranscriptSegment {
  start: number;
  end: number;
  text: string;
}

/**
 * Service for fetching and processing YouTube video transcripts.
 * Retrieves transcripts via `youtubei.js` and optionally punctuates them using a local ML model.
 * Extracts metadata like title, channel, and duration.
 */
export class YoutubeTranscriptHandler {
  private readonly OVERLAP_WORDS = 1;

  constructor(private punctuator: PunctuatorService) {}

  async fetchRecord(url: string) {
    const videoId = YoutubeTranscriptHandler.getVideoID(url);
    const raw = await this.transcriptYoutubeVideo(videoId);

    if (!raw) {
      return null;
    }

    const transcript = raw.autoGenerated
      ? await this.punctuateTranscript(raw.transcript)
      : raw.transcript;

    return {
      transcript,
      metadata: {
        title: raw.info.title,
        channel: raw.info.channel
          ? {
              id: raw.info.channel?.id,
              name: raw.info.channel?.name,
            }
          : null,
        videoId,
        duration: raw.info.duration,
        thumbnail: raw.info.thumbnail,
        description: raw.info.short_description,
        keywords: raw.info.keywords,
      },
    };
  }

  async transcriptYoutubeVideo(videoId: string) {
    const innertube = await Innertube.create({
      lang: 'en',
      retrieve_player: false,
    });

    const info = await innertube.getInfo(videoId);
    const transcriptData = await info.getTranscript();

    if (!transcriptData.transcript.content?.body?.initial_segments) {
      return null;
    }

    const transcript = transcriptData.transcript.content.body.initial_segments
      .filter((e) => !e.snippet.isEmpty())
      .map((segment) => ({
        start: Number(segment.start_ms),
        end: Number(segment.end_ms),
        text: segment.snippet.text ?? '',
      }));

    return {
      transcript,
      info: info.basic_info,
      autoGenerated:
        transcriptData.transcript.content.footer?.language_menu?.sub_menu_items
          ?.find((e) => e.selected == true)
          ?.title.includes('auto-generated'),
    };
  }

  async punctuateTranscript(transcript: YoutubeTranscriptSegment[]) {
    // NOTE: this will always assume each segment is at least OVERLAP_WORDS words long

    return transcript.reduce(async (pAcc, e, i, arr) => {
      const acc = await pAcc;
      const prevWords =
        i > 0 ? acc[i - 1]!.text.split(' ').slice(-this.OVERLAP_WORDS) : [];
      const nextWords =
        i < arr.length - 1
          ? arr[i + 1]!.text.split(' ').slice(0, this.OVERLAP_WORDS)
          : [];

      const str =
        `${prevWords.join(' ')} ${e.text} ${nextWords.join(' ')}`.trim();
      const punctuated = await this.punctuator.punctuate(str);

      const text = punctuated.text
        .split(' ')
        .slice(
          i > 0 ? this.OVERLAP_WORDS : 0,
          i < arr.length - 1 ? -this.OVERLAP_WORDS : undefined
        )
        .join(' ');

      acc.push({
        ...e,
        text,
      });

      return acc;
    }, Promise.resolve<YoutubeTranscriptSegment[]>([]));
  }

  public static getVideoID(url: string): string {
    const match =
      /.*(?:youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=)([^#&?]*).*/.exec(url);
    if (match !== null && match[1]?.length === 11) {
      return match[1];
    }
    throw new Error('Failed to get youtube video id from the url');
  }
}
